//! Functions to run the graphics command in the *draw* phase.
//!
//! See the documentation of the `renderer::graphics` module for more details.

use std::collections::HashSet;
use std::ffi::CStr;
use std::mem::{self, MaybeUninit};
use std::ptr;

use alacritty_terminal::graphics::{ColorType, GraphicData};

use lazy_static::lazy_static;
use log::trace;

use crate::gl;
use crate::gl::types::*;

use super::{shader, BlitGraphicData, RenderData, ResizeTextureData};

/// Run the `DeleteTextures` command.
///
/// All textures are deleted in a single call to `glDeleteTextures`.
#[inline]
pub(super) fn run_delete_textures(textures: Vec<GLuint>) {
    unsafe {
        trace!(target: "graphics", "Call glDeleteTextures with {} items", textures.len());
        gl::DeleteTextures(textures.len() as GLint, textures.as_ptr());
    }
}

/// Run the `InitTexture` command.
///
/// Configure a texture generated by `glGenTextures`, and initialize it with
/// the pixels from a `GraphicData` instance.
#[inline]
pub(super) fn run_init_texture(texture: GLuint, data: GraphicData) {
    unsafe {
        gl::BindTexture(gl::TEXTURE_2D, texture);
        configure_texture();

        gl::TexImage2D(
            gl::TEXTURE_2D,
            0,
            gl::RGBA as GLint,
            data.width as GLint,
            data.height as GLint,
            0,
            pixel_format(data.color_type),
            gl::UNSIGNED_BYTE,
            data.pixels.as_ptr().cast(),
        );

        gl::BindTexture(gl::TEXTURE_2D, 0);
    }
}

/// Run the `ResizeTexture` command.
///
/// The method to resize a texture depends on the extensions available in the
/// hardware. If [`GL_ARB_clear_texture`] and [`GL_ARB_copy_image`] are available,
/// the resize process is the following:
///
/// 1. Create an uninitialized texture.
/// 2. Fill it with transparent pixels with `glClearTexImage`.
/// 3. Copy the pixels of the previous texture with `glCopyImageSubData`.
///
/// If any of the extensions is missing, the process is the following:
///
/// 1. Create a texture and initialize it with transparent pixels from the CPU memory.
/// 2. Create a buffer object with enough capacity to store the pixels from the source texture.
/// 3. Copy the pixels of the source texture to the buffer object with `glGetTexImage`.
/// 4. Finally, apply those pixels to the target texture with `glTexSubImage2D`.
///
/// [`GL_ARB_clear_texture`]: https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_clear_texture.txt
/// [`GL_ARB_copy_image`]: https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_copy_image.txt
#[inline]
pub(super) fn run_resize_texture(mut resize_data: ResizeTextureData) {
    lazy_static! {
        // Check if the OpenGL extensions required for the fast implementation
        // of this function are available in the hardware.
        static ref EXTENSIONS_AVAILABLE: bool = {
            let required = ["GL_ARB_clear_texture", "GL_ARB_copy_image"];
            check_opengl_extensions(&required)
        };
    }

    trace!(
        target: "graphics",
        "Resize texture {} to width={}, height={} (EXTENSIONS_AVAILABLE={})",
        resize_data.source.texture.0,
        resize_data.width,
        resize_data.height,
        *EXTENSIONS_AVAILABLE,
    );

    let source_tex = mem::take(&mut resize_data.source.texture.0);

    unsafe {
        // Configure the target texture.
        gl::BindTexture(gl::TEXTURE_2D, resize_data.target_texture);
        configure_texture();
    }

    if *EXTENSIONS_AVAILABLE {
        unsafe {
            // Allocate memory for the texture with the new size.
            gl::TexImage2D(
                gl::TEXTURE_2D,
                0,
                gl::RGBA as GLint,
                resize_data.width as GLint,
                resize_data.height as GLint,
                0,
                gl::RGBA,
                gl::UNSIGNED_BYTE,
                ptr::null(),
            );

            gl::BindTexture(gl::TEXTURE_2D, 0);

            // Initialize its content with a transparent image.
            gl::ClearTexImage(
                resize_data.target_texture,
                0,
                gl::RGBA,
                gl::UNSIGNED_BYTE,
                [0u8; 4].as_ptr().cast(),
            );

            // Copy the pixels from the texture.
            gl::CopyImageSubData(
                source_tex,
                gl::TEXTURE_2D,
                0,
                0,
                0,
                0,
                resize_data.target_texture,
                gl::TEXTURE_2D,
                0,
                resize_data.source_offset as GLint,
                0,
                0,
                resize_data.source.width as GLint,
                resize_data.source.height as GLint,
                1,
            );
        }
    } else {
        // Pixels are copied to the new texture using an intermediate buffer in
        // the GPU. Unlike the previous method, we have to initialize the new
        // texture with data from the CPU.

        unsafe {
            // Initialize the target texture with zeros.
            let empty = vec![0; resize_data.width * resize_data.height * 4];
            gl::TexImage2D(
                gl::TEXTURE_2D,
                0,
                gl::RGBA as GLint,
                resize_data.width as GLint,
                resize_data.height as GLint,
                0,
                gl::RGBA,
                gl::UNSIGNED_BYTE,
                empty.as_ptr().cast(),
            );

            // Allocate a buffer to read the pixels.
            let mut buffer = 0;
            gl::GenBuffers(1, &mut buffer);
            gl::BindBuffer(gl::PIXEL_PACK_BUFFER, buffer);
            gl::BufferData(
                gl::PIXEL_PACK_BUFFER,
                (resize_data.source.width * resize_data.source.height * 4) as GLsizeiptr,
                ptr::null_mut(),
                gl::STREAM_COPY,
            );

            // Copy pixels from the source texture.
            gl::BindTexture(gl::TEXTURE_2D, source_tex);
            gl::GetTexImage(gl::TEXTURE_2D, 0, gl::RGBA, gl::UNSIGNED_BYTE, ptr::null_mut());

            // Finally, copy pixels to the target texture.
            gl::BindBuffer(gl::PIXEL_UNPACK_BUFFER, buffer);
            gl::BindTexture(gl::TEXTURE_2D, resize_data.target_texture);
            gl::TexSubImage2D(
                gl::TEXTURE_2D,
                0,
                resize_data.source_offset as GLint,
                0,
                resize_data.source.width as GLint,
                resize_data.source.height as GLint,
                gl::RGBA,
                gl::UNSIGNED_BYTE,
                ptr::null(),
            );

            // Clean up.
            gl::BindBuffer(gl::PIXEL_PACK_BUFFER, 0);
            gl::BindBuffer(gl::PIXEL_UNPACK_BUFFER, 0);
            gl::BindTexture(gl::TEXTURE_2D, 0);
            gl::DeleteBuffers(1, &buffer);
        }
    }

    unsafe {
        gl::DeleteTextures(1, &source_tex);
    }
}

/// Run the `BlitGraphic` command.
///
/// Update a region of an existing texture.
#[inline]
pub(super) fn run_blit_graphic(data: BlitGraphicData) {
    debug_assert_eq!(
        data.pixels.len(),
        data.width * data.height * data.color_type.bytes_per_pixel()
    );

    unsafe {
        gl::BindTexture(gl::TEXTURE_2D, data.texture);

        gl::TexSubImage2D(
            gl::TEXTURE_2D,
            0,
            data.offset_x as GLint,
            data.offset_y as GLint,
            data.width as GLint,
            data.height as GLint,
            pixel_format(data.color_type),
            gl::UNSIGNED_BYTE,
            data.pixels.as_ptr().cast(),
        );

        gl::BindTexture(gl::TEXTURE_2D, 0);
    }
}

/// Run the `Render` command.
///
/// First, shader uniforms are initialized with the values in the `RenderData`
/// instance. Then, vertices are collected in batches to minimize the invocations
/// of the shader program.
#[inline]
pub(super) fn run_render(program: &shader::GraphicsShaderProgram, data: RenderData) {
    // Initialize everything to use our rendering program.

    unsafe {
        gl::BindBuffer(gl::ARRAY_BUFFER, program.vbo);
        gl::BindVertexArray(program.vao);

        gl::UseProgram(program.id);

        gl::Uniform1f(program.u_base_position, data.graphics_line_offset);
        gl::Uniform2f(program.u_cell_dimensions, data.cell_width, data.cell_height);
        gl::Uniform2f(program.u_view_dimensions, data.view_width, data.view_height);

        gl::BlendFuncSeparate(gl::SRC_ALPHA, gl::ONE_MINUS_SRC_ALPHA, gl::SRC_ALPHA, gl::ONE);
    }

    // Array for storing the batch to render multiple graphics in a single call to the
    // shader program.
    //
    // Each graphic requires 6 vertices (2 triangles to make a rectangle), and we will
    // never have more than `TEXTURES_ARRAY_SIZE` graphics in a single call, so we set
    // the array size to the maximum value that we can use.
    let mut batch = [MaybeUninit::uninit(); shader::TEXTURES_ARRAY_SIZE * 6];
    let mut batch_size = 0;

    macro_rules! send_batch {
        () => {
            #[allow(unused_assignments)]
            if batch_size > 0 {
                trace!(target: "graphics", "Call glDrawArrays with {} items", batch_size);

                unsafe {
                    gl::BufferData(
                        gl::ARRAY_BUFFER,
                        (batch_size * mem::size_of::<shader::Vertex>()) as isize,
                        batch.as_ptr().cast(),
                        gl::STREAM_DRAW,
                    );

                    gl::DrawArrays(gl::TRIANGLES, 0, batch_size as GLint);
                }

                batch_size = 0;
            }
        };
    }

    // In order to send textures to the shader program we need to get a _slot_
    // for every texture associated to a graphic.
    //
    // We have up to `u_textures.len()` slots available in each execution of
    // the shader, which was computed when `GraphicsShaderProgram` is
    // initialized, and it is never greater than `TEXTURES_ARRAY_SIZE`.
    //
    // For each slot we need three values:
    //
    // - The texture unit for `glActiveTexture` (`GL_TEXTUREi`).
    // - The uniform location for `textures[i]`.
    // - The index `i`, used to set the value of the uniform.
    //
    // These values are generated using the `tex_slots_generator` iterator.
    //
    // A single graphic has 6 vertices. All vertices will use the same texture
    // slot. To detect if a texture has already a slot, we only need to compare
    // with the last texture (`last_tex_slot`) because all the vertices of a
    // single graphic are consecutive.
    //
    // When all slots are occupied, or the batch array is full, the current
    // batch is sent and the iterator is reset.
    //
    // This logic could be simplified using the [Bindless Texture extension],
    // but it is not a core feature of any OpenGL version, so hardware support
    // is uncertain.
    //
    // [Bindless Texture extension]: https://www.khronos.org/opengl/wiki/Bindless_Texture

    let tex_slots_generator = (gl::TEXTURE0..=gl::TEXTURE31)
        .zip(program.u_textures.iter())
        .zip(0_u32..)
        .map(|((tex_enum, &u_texture), index)| (tex_enum, u_texture, index));

    let mut tex_slots = tex_slots_generator.clone();

    // Keep the last allocated slot in a `(texture id, index)` tuple.
    let mut last_tex_slot = (0, 0);

    for mut vertex in data.vertices {
        // Check if we can reuse the last texture slot.
        if last_tex_slot.0 != vertex.texture_id {
            last_tex_slot = loop {
                match tex_slots.next() {
                    None => {
                        // No more slots. Send the batch and reset the iterator.
                        send_batch!();
                        tex_slots = tex_slots_generator.clone();
                    },

                    Some((tex_enum, u_texture, index)) => {
                        unsafe {
                            gl::ActiveTexture(tex_enum);
                            gl::BindTexture(gl::TEXTURE_2D, vertex.texture_id);
                            gl::Uniform1i(u_texture, index as GLint);
                        }

                        break (vertex.texture_id, index);
                    },
                }
            };
        }

        vertex.texture_id = last_tex_slot.1;
        batch[batch_size] = MaybeUninit::new(vertex);
        batch_size += 1;

        if batch_size == batch.len() {
            send_batch!();
        }
    }

    send_batch!();

    // Reset state.
    unsafe {
        gl::BlendFunc(gl::SRC1_COLOR, gl::ONE_MINUS_SRC1_COLOR);

        gl::ActiveTexture(gl::TEXTURE0);
        gl::BindTexture(gl::TEXTURE_2D, 0);

        gl::UseProgram(0);
        gl::BindVertexArray(0);
        gl::BindBuffer(gl::ARRAY_BUFFER, 0);
    }
}

#[inline]
fn pixel_format(color_type: ColorType) -> GLenum {
    match color_type {
        ColorType::RGB => gl::RGB,
        ColorType::RGBA => gl::RGBA,
    }
}

#[inline]
unsafe fn configure_texture() {
    gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_MAX_LEVEL, 0);
    gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_WRAP_S, gl::CLAMP_TO_EDGE as GLint);
    gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_WRAP_T, gl::CLAMP_TO_EDGE as GLint);
    gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_MIN_FILTER, gl::LINEAR as GLint);
    gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_MAG_FILTER, gl::LINEAR as GLint);
}

/// Check if the OpenGL extensions are available in this hardware.
fn check_opengl_extensions(extensions: &[&str]) -> bool {
    // Use a HashSet to track extensions needed to be found. When the set is
    // empty, we know that all extensions are available.
    let mut needed: HashSet<_> = extensions.iter().collect();

    let mut num_exts = 0;
    unsafe {
        gl::GetIntegerv(gl::NUM_EXTENSIONS, &mut num_exts);
    }

    for index in 0..num_exts as GLuint {
        let pointer = unsafe { gl::GetStringi(gl::EXTENSIONS, index) };
        if pointer.is_null() {
            log::warn!("Can't get OpenGL extension name at index {} of {}", index, num_exts);
            return false;
        }

        let extension = unsafe { CStr::from_ptr(pointer.cast()) };
        if let Ok(ext) = extension.to_str() {
            if needed.remove(&ext) && needed.is_empty() {
                return true;
            }
        }
    }

    log::info!("Missing OpenGL extensions: {:?}", needed);
    false
}
